<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Martin R. Smith" />

<meta name="date" content="2023-03-29" />

<title>Profile parsimony</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>






<style type="text/css">

div.csl-bib-body { }
div.csl-entry {
clear: both;
}
.hanging div.csl-entry {
margin-left:2em;
text-indent:-2em;
}
div.csl-left-margin {
min-width:2em;
float:left;
}
div.csl-right-inline {
margin-left:2em;
padding-left:1em;
}
div.csl-indent {
margin-left: 2em;
}
</style>

<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Profile parsimony</h1>
<h4 class="author">Martin R. Smith</h4>
<h4 class="date">2023-03-29</h4>



<div id="scope-of-this-document" class="section level2">
<h2>Scope of this document</h2>
<p>This document aims to give a flavour of the justification for using
parsimony in general, and profile parsimony in particular, to
reconstruct evolutionary history; and to summarize the
mathematical/information theoretic underpinning of the profile parsimony
approach.</p>
<p>I’ll open by acknowledging that a philosophical approach is not
everyone’s cup of tea – it’s certainly not my home turf. I tend to
prefer models that can be shown to work well, without worrying too much
about their abstract philosophy – though admittedly, identifying a
‘best’ method is not always straightforward <span class="citation">(e.g.
Smith, 2019)</span>.</p>
<p>I should also acknowledge that practical considerations can influence
the choice of reconstruction method: a tip-dated phylogeny cannot be
accomplished in a parsimony framework, for example; and where a
principled model of evolutionary change is available, as with certain
subsets of molecular data, some see a compelling case for using such
models to infer phylogeny.</p>
<p>My goal here is not to argue that any method is superior, but to
develop a case that profile parsimony rests on a principled underpinning
– and, if it does prove to outperform other methods in certain
circumstances, to give a sense of why this might be.</p>
</div>
<div id="a-philosophy-of-parsimony" class="section level2">
<h2>A philosophy of parsimony</h2>
<p>There are a number of complementary perspectives on the philosophical
justification for a parsimony approach <span class="citation">(e.g.
Farris, 1983)</span>, which this brief overview will not do justice to;
but hopefully my unqualified and largely unreferenced perspective
captures some of the nature of the principal arguments. Better-versed
readers are invited to suggest improvements or modifications by e-mail
or by opening a <a href="https://github.com/ms609/TreeSearch/issues/new/">GitHub
issue</a>.</p>
<p>Parsimony has been defended by reference to Occam’s Razor: the
principle that scientists should prefer the simplest explanation that
can provide an adequate account for observed data. In the context of
morphological phylogenetics, “observed data” are codified as observed
character states scored within a matrix. Ideally, a phylogenetic tree
would explain the distribution of character states between taxa by
reconstructing each character state as representing a homologous
feature, with a single evolutionary origin on the tree. An explanation
in which a certain trait evolved once is simpler than one in which that
trait evolved twice; it is less faithful to the information inherent in
the character coding, and attributes less of this information to common
ancestry. Each additional step on a tree can be viewed as an additional
“assumption”, and on a simple or “pure” view, the tree that makes the
fewest assumptions should be preferred.</p>
<p>However, this perspective – which implicitly underpins the practice
of <em>equal-weights</em> parsimony – treats all assumptions as
equivalent; the simplest hypothesis is the one that makes the fewest
assumptions (here, assumptions of homoplasy).</p>
<p>A more nuanced interpretation of Occam’s Razor suggests that the
simplest hypothesis is the one that is least surprising. A hypothesis
predicated on the existence of a flying spaghetti monster may require
only a single (barmy) assumption, but we might nevertheless tend to
prefer a hypothesis that requires a greater number of assumptions that
are better aligned with previous experience.</p>
<div id="application-of-occams-razor" class="section level3">
<h3>Application of Occam’s Razor</h3>
<p>This interpretation has two applications for phylogenetics. The first
is that we may wish to prefer trees (which are depictions of
phylogenetic hypotheses) that concentrate homoplasy in characters that
we believe to be prone to convergent evolution. This view calls for
<em>character weighting</em>, that is, assigning less weight to changes
in characters that are believed to be less phylogenetically reliable.
Such characters may be identified by successive approximations <span class="citation">(Farris, 1969)</span>, by comparing the pattern of
their tokens with that of other characters, by expert judgement, or by
other <em>a priori</em> means.</p>
<p>The second application argues that each additional case of homoplasy
beyond the first is successively less surprising: the first observation
of homoplasy (rather than some prior intuition) taught us that the
character was not entirely reliable, making a second homoplasy less
unexpected; the second observed homoplasy, in turn, makes us less
surprised by the third. This approach calls for a <em>step
weighting</em> approach, in which each additional step in a given
character receives less penalty than the last. (Mathematically, this can
be expressed in as if it were a character weighting strategy; but I feel
that its <em>a posteriori</em> nature conveys a subtly different
motivation and justifies a separate treatment.)</p>
<p>This raises the question of how each step beyond the first ought to
be penalized. Ultimately, any concave function (in which each step is
penalized by a positive amount that is smaller than the penalty applied
to the previous step) is consistent with this philosophy <span class="citation">(Arias &amp; Miranda-Esquivel, 2004)</span>. The most
widely used step weighting approach is Goloboff’s <span class="citation">(1993)</span> implied weighting, where the total cost
associated with a character is expressed as <em>e</em> / (<em>e</em> +
<em>k</em>), where <em>e</em> is the number of homoplasies within a
character, and <em>k</em> is an arbitrary constant. As <em>e</em> tends
to infinity, this approach tends to equal weights; as <em>k</em> tends
to zero, it tends to clique analysis (in which a character is either
homologous or ignored) <span class="citation">(Farris, 1983)</span>. The
most appropriate value for <em>k</em> may depend on the number of taxa,
the number and distribution of observed states, and other factors <span class="citation">(Goloboff, Carpenter, Arias, &amp; Esquivel, 2008;
Goloboff, Torres, &amp; Arias, 2018)</span> (a more detailed treatment
will be provided in a revision of this document). Moreover, some
adjustment must be made for ‘missing’ data, i.e. ambiguous tokens, which
reduce the opportunity to observe homoplasy <span class="citation">(Goloboff, 2014)</span>. Implied weighting is described
as an approximation <span class="citation">(Goloboff, 1993)</span>, and
I am not aware of a straightforward interpretation of the ‘fit’ score,
or a principled definition of the nature of the quantity that is being
approximated.</p>
</div>
<div id="an-information-theoretic-basis" class="section level3">
<h3>An information theoretic basis</h3>
<p>I argue that the quantity that we should seek to minimise is the
“surprise” of a tree. Information theory is the science of quantifying
unexpectedness. Information is usually measured in <em>bits</em>. One
bit is the amount of information generated by tossing a fair coin: to
record the outcome of a coin toss, I must record either a <code>H</code>
or a <code>T</code>, and with each of the two symbols equally likely,
there is no way to compress the results of multiple tosses.</p>
<p>The Shannon <span class="citation">(1948)</span> information content
of an outcome <span class="math inline">\(x\)</span> is defined to be
<span class="math inline">\(h(x) = -\log_2{P(x)}\)</span>, which
simplifies to <span class="math inline">\(\log_2{n}\)</span> when all
<span class="math inline">\(n\)</span> outcomes are equally likely.
Thus, the outcome of a fair coin toss delivers <span class="math inline">\(\log_2{2} = 1\textrm{ bit}\)</span> of
information; the outcome of rolling a fair six-sided die contains <span class="math inline">\(\log_2{6} \approx 2.58\textrm{ bits}\)</span> of
information; and the outcome of selecting at random one of the 105
unrooted binary six-leaf trees is <span class="math inline">\(\log_2{105} \approx 6.71\textrm{
bits}\)</span>.</p>
<p>Unlikely outcomes are more surprising, and thus contain more
information than likely outcomes. The information content of rolling a
twelve on two fair six-sided dice is <span class="math inline">\(-\log_2{\frac{1}{36}} \approx 5.16\textrm{
bits}\)</span>, whereas a seven, which could be produced by six of the
36 possible rolls (<code>1 &amp; 6</code>, <code>2 &amp; 5</code>, …),
is less surprising, and thus contains less information: <span class="math inline">\(-\log_2{\frac{6}{36}} \approx 2.58\textrm{
bits}\)</span>. An additional 2.58 bits of information would be required
to establish whether which of the rolls <code>1 &amp; 6</code>,
<code>2 &amp; 5</code>, … occurred.</p>
<p>Now consider two competing explanations for an event: (i), three
consecutive rolls of two dice each produced a seven; (ii), two
consecutive rolls of two dice each produced a twelve. The former event
corresponds to <span class="math inline">\(3 \times 2.58 = 7.75\textrm{
bits}\)</span> of information, so is less surprising than the latter,
which represents <span class="math inline">\(2 \times 5.16 =
10.34\textrm{ bits}\)</span>, despite involving an additional roll of
the dice.</p>
<p>How do we measure the “surprise” associated with additional steps in
a character on a phylogenetic tree? Consider a character with the states
<code>0 0 0 1 1 1</code>. In the most parsimonious situation in which
the character contains a single step on a tree, it is compatible with
nine of the 105 labelled six-leaf trees, and thus represents <span class="math inline">\(-log_2\frac{9}{105} = 3.54\textrm{ bits}\)</span>
of phylogenetic information. If we are told that the character contains
exactly two steps, it can occur on 63 trees, so yields <span class="math inline">\(-log_2\frac{63}{105} = 0.74\textrm{
bits}\)</span>. (The number of trees with <em>m</em> extra steps can be
calculated using theorem 1 of <span class="citation">Carter, Hendy,
Penny, Székely, &amp; Wormald (1990)</span>, implemented in the function
<a href="https://ms609.github.io/TreeSearch/reference/Carter1.html"><code>Carter1()</code></a>.)
Learning that a second step occurred meant that 3.54 − 0.74 = 2.81 bits
of information we had previously attributed to common ancestry instead
represent a signature of homoplasy; this quantity measures our degree of
‘surprise’.</p>
<p>If we subsequently learn that the character contains three steps,
then it can occur on any six-leaf tree, and contains no phylogenetic
information. We are less surprised by this third step, which attributes
the remaining 0.74 bits of information to factors other than common
ancestry, because the second step had already reduced the amount of
phylogenetic information we expected the character to hold.</p>
</div>
</div>
<div id="profile-parsimony" class="section level2">
<h2>Profile parsimony</h2>
<p>Although this is not how the approach was initially justified <span class="citation">(Faith &amp; Trueman, 2001)</span>, profile parsimony
aims to ascribe as much of the information in each character as possible
to common ancestry; in the example above, it assigns the first extra
step a penalty of 2.81, and the second extra step a penalty of 0.74,
corresponding to the amount of information that could no longer be
assigned to common ancestry after learning of the existence of the <span class="math inline">\(n\)</span>th step.</p>
<p>Whereas the value of a parsimony score obtained under implied weights
does not have any inherent meaning, the profile parsimony score of a
given tree represents the amount of information within a character
matrix that can be attributed to common ancestry under that tree, which,
if expressed as a proportion of the total cladistic information content
of the characters in the matrix <span class="citation">(Cotton &amp;
Wilkinson, 2008)</span>, gives an indication of the degree of homoplasy
in the underlying character matrix.</p>
<p>Profile parsimony produces a concavity profile that reflects the
opportunity to observe additional steps in each character, unlike
implied weighting, where a single concavity value is applied to all
characters, regardless of the opportunity for additional steps to be
observed.</p>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>The graph shows the profiles under implied weighting (with different
concavity constants) and profile parsimony (under different
distributions of the tokens <code>0</code> and <code>1</code> in a
character coded for forty leaves). One prominent difference between the
character of concavity profiles is that implied weighting continues to
assign relatively large penalties to additional steps even when the
distribution of a character is almost random on a tree. Another is that
profile parsimony treats a second (and each subsequent) step as less
surprising if there are fewer opportunities to observe a second step by
chance, on account of there being a smaller number of tokens with the
rarer step; implied weighting is blind to the distribution of tokens
within a character.</p>
</div>
<div id="implementation" class="section level2">
<h2>Implementation</h2>
<p>The present implementation of profile parsimony in “TreeSearch” is
restricted: inapplicable tokens are treated as ambiguous; partial
ambiguity (e.g. <code>{02}</code>) is treated as complete
(<code>?</code>), and informative states (i.e. states present in more
than one taxon) beyond the first two are ignored (treated as ambiguous).
This reflects the complicated mathematics of calculating the number of
trees with a given number of steps.</p>
<p>Tree length can be calculated with <a href="https://ms609.github.io/TreeSearch/reference/TreeLength.html"><code>TreeLength(concavity = &quot;profile&quot;)</code></a>,
and tree search performed with <a href="https://ms609.github.io/TreeSearch/reference/MaximizeParsimony.html"><code>MaximizeParsimony(concavity = &quot;profile&quot;)</code></a>.
Data can be prepared for profile parsimony using <a href="https://ms609.github.io/TreeSearch/reference/PrepareDataProfile.html"><code>PrepareDataProfile()</code></a>,
and the profile of a character calculated using <a href="https://ms609.github.io/TreeSearch/reference/StepInformation.html"><code>StepInformation()</code></a>.</p>
</div>
<div id="where-next" class="section level2">
<h2>Where next</h2>
<ul>
<li>Conduct <a href="profile.html">tree search</a> using profile
parsimony</li>
</ul>
</div>
<div id="references" class="section level2 unnumbered">
<h2 class="unnumbered">References</h2>
<div id="refs" class="references csl-bib-body hanging-indent" line-spacing="2">
<div id="ref-Arias2004" class="csl-entry">
Arias, J. S., &amp; Miranda-Esquivel, D. R. (2004). Profile parsimony
(<span>PP</span>): An analysis under implied weights (<span>IW</span>).
<em>Cladistics</em>, <em>20</em>(1), 56–63. doi:<a href="https://doi.org/10.1111/j.1096-0031.2003.00001.x">10.1111/j.1096-0031.2003.00001.x</a>
</div>
<div id="ref-Carter1990" class="csl-entry">
Carter, M., Hendy, M., Penny, D., Székely, L. A., &amp; Wormald, N. C.
(1990). On the distribution of lengths of evolutionary trees. <em>SIAM
Journal on Discrete Mathematics</em>, <em>3</em>(1), 38–47. doi:<a href="https://doi.org/10.1137/0403005">10.1137/0403005</a>
</div>
<div id="ref-Cotton2008" class="csl-entry">
Cotton, J., &amp; Wilkinson, M. (2008). Quantifying the potential
utility of phylogenetic characters. <em>Taxon</em>, <em>57</em>(1),
131–136.
</div>
<div id="ref-Faith2001" class="csl-entry">
Faith, D. P., &amp; Trueman, J. W. H. (2001). <span class="nocase">Towards an inclusive philosophy for phylogenetic
inference</span>. <em>Systematic Biology</em>, <em>50</em>(3), 331–350.
doi:<a href="https://doi.org/10.1080/10635150118627">10.1080/10635150118627</a>
</div>
<div id="ref-Farris1969" class="csl-entry">
Farris, J. S. (1969). A successive approximations approach to character
weighting. <em>Systematic Biology</em>, <em>18</em>(4), 374–385. doi:<a href="https://doi.org/10.2307/2412182">10.2307/2412182</a>
</div>
<div id="ref-Farris1983" class="csl-entry">
Farris, J. S. (1983). The logical basis of phylogenetic analysis. In N.
Platnick &amp; V. A. Funk (Eds.), <em>Advances in
<span>Cladistics</span>, <span>Vol</span>. 2</em> (pp. 7–36). <span>New
York</span>: <span>Columbia University Press</span>.
</div>
<div id="ref-Goloboff1993" class="csl-entry">
Goloboff, P. A. (1993). Estimating character weights during tree search.
<em>Cladistics</em>, <em>9</em>(1), 83–91. doi:<a href="https://doi.org/10.1111/j.1096-0031.1993.tb00209.x">10.1111/j.1096-0031.1993.tb00209.x</a>
</div>
<div id="ref-Goloboff2014" class="csl-entry">
Goloboff, P. A. (2014). Extended implied weighting. <em>Cladistics</em>,
<em>30</em>(3), 260–272. doi:<a href="https://doi.org/10.1111/cla.12047">10.1111/cla.12047</a>
</div>
<div id="ref-Goloboff2008" class="csl-entry">
Goloboff, P. A., Carpenter, J. M., Arias, J. S., &amp; Esquivel, D. R.
M. (2008). Weighting against homoplasy improves phylogenetic analysis of
morphological data sets. <em>Cladistics</em>, <em>24</em>(5), 758–773.
doi:<a href="https://doi.org/10.1111/j.1096-0031.2008.00209.x">10.1111/j.1096-0031.2008.00209.x</a>
</div>
<div id="ref-Goloboff2018" class="csl-entry">
Goloboff, P. A., Torres, A., &amp; Arias, J. S. (2018). Weighted
parsimony outperforms other methods of phylogenetic inference under
models appropriate for morphology. <em>Cladistics</em>, <em>34</em>(4),
407–437. doi:<a href="https://doi.org/10.1111/cla.12205">10.1111/cla.12205</a>
</div>
<div id="ref-Shannon1948" class="csl-entry">
Shannon, C. E. (1948). A mathematical theory of communication. <em>Bell
System Technical Journal</em>, <em>27</em>, 379–423, 623–656.
</div>
<div id="ref-Smith2019" class="csl-entry">
Smith, M. R. (2019). Bayesian and parsimony approaches reconstruct
informative trees from simulated morphological datasets. <em>Biology
Letters</em>, <em>15</em>(2), 20180632. doi:<a href="https://doi.org/10.1098/rsbl.2018.0632">10.1098/rsbl.2018.0632</a>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
